@page "/products/"
@* @rendermode InteractiveServer *@
@* Disable prerender so request are only done once*@
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@inject IDbContextFactory<ReceiptsContext> DbFactory
@inject NavigationManager Navigation

<PageTitle>Produits</PageTitle>

<h1>Produits</h1>


@if (Loading)
{
    <p><em>Chargement...</em></p>
}
else
{
    <p>
        <span>Filtrer par groupe:</span>
        <select @bind="FilterGroup">
            @if (GroupList != null)
            {
                <option value=""></option>
                foreach (var group in GroupList)
                {
                        <option value="@group">@group</option>
                }
            }
        </select>
        <span>&nbsp; &nbsp; &nbsp;</span>
        <span>Trouver par nom : </span>

        @* <input type="text" @bind-value="SearchString" @bind-value:event="oninput" /> *@

        <div class="autocomplete w-25">
            <input type="text" @bind="SearchString" @oninput="HandleInput" @onblur="ClearSearchList" />
            @if (searchList is not null)
            {
                @if (searchList.Any())
                {
                    <ul class="options">

                        @foreach (var customer in searchList)
                        {
                            <li class="option" @onclick=@(_ => SelectProduct(customer))>
                                <span class="option-text">@customer</span>
                            </li>
                        }

                    @* else
                    {
                        <li class="disabled option">Pas de résultat</li>
                    } *@
                    </ul>
                }
            }
        </div>
        @* @bind-value:event="oninput" *@
        <span>Trier par : </span>
        <select @bind="Sort">
            @if (SortList != null)
            {
                foreach (var sort in SortList)
                {
                    <option value="@sort">@GetSortName(sort)</option>
                }
            }
        </select>
    </p>
    <button class="btn hoverblue" @onclick="ReloadAsync">Rechercher</button>
    <button class="btn hoverblue" @onclick="Clear">Effacer</button>

    <table class="table alternateLines">
        <thead>
            <tr>
                <th>Groupe</th>
                <th>Nom</th>
                <th>Prix</th>
                <th>Date de réception</th>
            </tr>
        </thead>
        <tbody>
            @if (productsList != null)
            {
                @foreach (var product in productsList)
                {
                    <tr>
                        <td>@product.Group</td>
                        <td>@product.Name</td>
                        <td>@product.Price</td>
                        <td>@product.DateReceipt.ToShortDateString()</td>
                        <td>
                            <a title="Détails" href="details/@product.Id" style="text-decoration:none">
                                &nbsp;🔍&nbsp;
                            </a>
                            <button title="Prix" class="btn" @onclick="() => ShowPrices(product.Id)">
                                📈
                            </button>
                            @* <a title="Edit" href="edit/@product.Id" style="text-decoration:none">
                                &nbsp;📝&nbsp;
                            </a> *@
                        </td>
                    </tr>
                }
            }
        </tbody>
    </table>

    <span>@(TotalPages == 0 ? 0 : Page) sur @TotalPages</span>
    <span>&nbsp;</span>

    <button class="btn btn-primary @IsDisabled(Page != 1)" @onclick="GoFirstPage">Première</button>
    <button class="btn btn-primary @IsDisabled(HasPrev)" @onclick="GoPreviousPage">Précédent</button>
    <button class="btn btn-primary @IsDisabled(HasNext)" @onclick="GoNextPage">Suivant</button>
    <button class="btn btn-primary @IsDisabled(Page != TotalPages)" @onclick="GoLastPage">Dernière</button>



    @if (ShowPopup)
    {
        <!-- This is the popup  -->
        <div class="modal" tabindex="-1" style="display:block" role="dialog">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Historique des prix</h5>
                        <!-- Button to close the popup -->
                        <button type="button" class="close"
                                @onclick="ClosePopup">
                            <span aria-hidden="true">X</span>
                        </button>
                    </div>
                    <!-- Modal body -->
                    <div class="modal-body">
                        <ProductPrices ProductId="@ShowPricesProductId"></ProductPrices>
                    </div>
                </div>
            </div>
        </div>
    }
}


@code {
    // The products list
    private Product[]? productsList;

    private bool Loading = true;



    // Current page
    // [Parameter]
    public int Page { get; set; }

    // [Parameter]
    public string? Sort { get; set; }

    //[Parameter]
    public string? FilterGroup { get; set; }

    //[Parameter]
    public string? SearchString { get; set; }

    //[Parameter]
    public bool? Products1price { get; set; }

    private int TotalPages { get; set; }

    // Previous page management
    private bool HasPrev { get; set; }

    // Next page management
    private bool HasNext { get; set; }

    private List<string>? GroupList { get; set; }

    private List<string>? SortList { get; set; }

    // Helper method to set disabled on class for paging.
    // condition: When the element is active (and therefore should not be disabled).
    //            Returns the string literal "disabled" or an empty string.
    private string IsDisabled(bool condition) =>
        !Loading && condition ? "" : "disabled";

    private bool ShowPopup = false;
    private int ShowPricesProductId;
    void ShowPrices(int productId)
    {
        // Open the Popup
        ShowPopup = true;
        ShowPricesProductId = productId;
    }

    void ClosePopup()
    {
        // Close the Popup
        ShowPopup = false;
    }

    protected override async Task OnParametersSetAsync()
    {
        await ReloadAsync();

        await base.OnParametersSetAsync();
    }

    private string GetSortName(string sort)
    {
        switch (sort)
        {
            case "Name":
                return "Nom";
            case "DateReceipt":
                return "Date de réception";
            default:
                return "Groupe";
        }
    }

    private async Task ReloadAsync()
    {
        int pageSize = 10;

        using var context = DbFactory.CreateDbContext();

        GroupList = context.Products.Select(p => p.Group).Distinct().ToList();
        SortList = new List<string>{ "Group", "DateReceipt", "Name"};

        Loading = true;

        IQueryable<Product> products = context.Products;

        //Filter
        if (!String.IsNullOrEmpty(FilterGroup))
        {
            products = products.Where(s => s.Group.Equals(FilterGroup));
        }

        if (!String.IsNullOrEmpty(SearchString))
        {
            products = products.Where(s => s.Name.Contains(SearchString));
        }

        //Sort
        if (Sort == "DateReceipt")
        {
            products = products.OrderByDescending(p => p.DateReceipt);
        }
        else if (Sort == "Name")
        {
            products = products.OrderBy(p => p.Name);
        }
        else //Group or unknown
        {
            products = products.OrderBy(p => p.Group).ThenBy(p => p.Name).ThenBy(p => p.DateReceipt);
        }

        var count = await products.CountAsync();
        TotalPages = (int)Math.Ceiling(count / (double)pageSize);

        if (Page > TotalPages)
        {
            Page = TotalPages;
        }
        if (Page <= 0)
        {
            Page = 1;
        }

        HasPrev = Page > 1;
        HasNext = Page < TotalPages;

        productsList = await products.Skip((Page - 1) * pageSize).Take(pageSize).ToArrayAsync();

        Loading = false;
    }

    private async Task Clear()
    {
        Page = 1;
        Sort = null;
        FilterGroup = null;
        SearchString = null;
        Products1price = null;

        await ReloadAsync();
    }

    private async Task GoFirstPage()
    {
        Page = 1;

        await ReloadAsync();
    }


    private async Task GoPreviousPage()
    {
        Page--;

        await ReloadAsync();
    }

    private async Task GoNextPage()
    {
        Page++;

        await ReloadAsync();
    }

    private async Task GoLastPage()
    {
        Page = TotalPages;

        await ReloadAsync();
    }

    private async Task<IEnumerable<string>> SearchProducts(string searchText)
    {
        using var context = DbFactory.CreateDbContext();

        return await Task.FromResult(context.Products.Where(
                     x => x.Name.ToLower().Contains(searchText.ToLower())).Select(p => p.Name).Distinct().Take(10).ToList());
    }

    // Wait period in (ms) after the user stops typing.
    const int DebounceMs = 1000;

    // Timer for debounce.
    System.Timers.Timer? timer;

    private IEnumerable<string>? searchList;

    /* async */ void HandleInput(ChangeEventArgs e)
    {
        SearchString = e?.Value?.ToString();
                    /*
                    if (SearchString != null)
                {
                searchList = await SearchProducts(SearchString);
                    }
                    else
                {
                searchList = null;
                }
        return;
        */

        timer?.Dispose();
        timer = new(DebounceMs);
        timer.Elapsed += NotifyTimerElapsed;
        timer.Enabled = true;
    }

    // Fired after debounce time.
    // sender: Timer
    // e: Event args
    private async void NotifyTimerElapsed(object? sender, System.Timers.ElapsedEventArgs e)
    {
        timer?.Dispose();
        timer = null;
        if (SearchString != null)
        {
            searchList = await SearchProducts(SearchString);

            StateHasChanged();
        }
        else
        {
            searchList = null;
        }
    }

    void SelectProduct(string product)
    {
        SearchString = product;
        searchList = null;
        StateHasChanged();
    }

    void ClearSearchList()
    {
        searchList = null;
    }
}
