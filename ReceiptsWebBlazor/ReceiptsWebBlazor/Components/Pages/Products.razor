@page "/products/"
@* @rendermode InteractiveServer *@
@* Disable prerender so request are only done once*@
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@inject IDbContextFactory<ReceiptsContext> DbFactory
@inject NavigationManager Navigation

<PageTitle>Produits</PageTitle>

<h1>Produits</h1>


@if (Loading)
{
    <p><em>Chargement...</em></p>
}
else
{
    <p>
    <span>Filtrer par groupe:</span>
    <select @bind="FilterGroup">
        @if (GroupList != null)
        {
            <option value=""></option>
            foreach (var group in GroupList)
            {
                    <option value="@group">@group</option>
            }
        }
    </select>
    <span>&nbsp; &nbsp; &nbsp;</span>
    <span>Trouver par nom : </span>
    <input type="text" id="SearchStringAutocomplete" @bind-value="SearchString" @bind-value:event="oninput" />
        <span>Trier par : </span>
        <select @bind="Sort">
            @if (SortList != null)
            {
                foreach (var sort in SortList)
                {
                    <option value="@sort">@GetSortName(sort)</option>
                }
            }
        </select>
    </p>
    <button class="btn hoverblue" @onclick="ReloadAsync">Rechercher</button>
    <button class="btn hoverblue" @onclick="Clear">Effacer</button>

    <table class="table alternateLines">
        <thead>
            <tr>
                <th>Groupe</th>
                <th>Nom</th>
                <th>Prix</th>
                <th>Date de réception</th>
            </tr>
        </thead>
        <tbody>
            @if (productsList != null)
            {
                @foreach (var product in productsList)
                {
                    <tr>
                        <td>@product.Group</td>
                        <td>@product.Name</td>
                        <td>@product.Price</td>
                        <td>@product.DateReceipt.ToShortDateString()</td>
                        <td>
                            <a title="Détails" href="details/@product.Id" style="text-decoration:none">
                                &nbsp;🔍&nbsp;
                            </a>
                            @* <a title="Edit" href="edit/@product.Id" style="text-decoration:none">
                                &nbsp;📝&nbsp;
                            </a> *@
                        </td>
                    </tr>
                }
            }
        </tbody>
    </table>

    <span>@(TotalPages == 0 ? 0 : Page) sur @TotalPages</span>
    <span>&nbsp;</span>

    <button class="btn btn-primary @IsDisabled(Page != 1)" @onclick="GoFirstPage">Première</button>
    <button class="btn btn-primary @IsDisabled(HasPrev)" @onclick="GoPreviousPage">Précédent</button>
    <button class="btn btn-primary @IsDisabled(HasNext)" @onclick="GoNextPage">Suivant</button>
    <button class="btn btn-primary @IsDisabled(Page != TotalPages)" @onclick="GoLastPage">Dernière</button>
}


@code {
    // The products list
    private Product[]? productsList;

    private bool Loading = true;

    // Current page
    // [Parameter]
    public int Page { get; set; }

    // [Parameter]
    public string? Sort { get; set; }

    //[Parameter]
    public string? FilterGroup { get; set; }

    //[Parameter]
    public string? SearchString { get; set; }

    //[Parameter]
    public bool? Products1price { get; set; }

    private int TotalPages { get; set; }

    // Previous page management
    private bool HasPrev { get; set; }

    // Next page management
    private bool HasNext { get; set; }

    private List<string>? GroupList { get; set; }

    private List<string>? SortList { get; set; }

    // Helper method to set disabled on class for paging.
    // condition: When the element is active (and therefore should not be disabled).
    //            Returns the string literal "disabled" or an empty string.
    private string IsDisabled(bool condition) =>
        !Loading && condition ? "" : "disabled";

    protected override async Task OnParametersSetAsync()
    {
        await ReloadAsync();

        await base.OnParametersSetAsync();
    }

    private string GetSortName(string sort)
    {
        switch (sort)
        {
            case "Name":
                return "Nom";
            case "DateReceipt":
                return "Date de réception";
            default:
                return "Groupe";
        }
    }

    private async Task ReloadAsync()
    {
        int pageSize = 10;

        using var context = DbFactory.CreateDbContext();

        GroupList = context.Products.Select(p => p.Group).Distinct().ToList();
        SortList = new List<string>{ "Group", "DateReceipt", "Name"};

        Loading = true;

        //await Task.Delay(500);

        IQueryable<Product> products = context.Products;

        //Filter
        if (!String.IsNullOrEmpty(FilterGroup))
        {
            products = products.Where(s => s.Group.Equals(FilterGroup));
        }

        if (!String.IsNullOrEmpty(SearchString))
        {
            products = products.Where(s => s.Name.Contains(SearchString));
        }

        //Sort
        if (Sort == "DateReceipt")
        {
            products = products.OrderByDescending(p => p.DateReceipt);
        }
        else if (Sort == "Name")
        {
            products = products.OrderBy(p => p.Name);
        }
        else //Group or unknown
        {
            products = products.OrderBy(p => p.Group).ThenBy(p => p.Name).ThenBy(p => p.DateReceipt);
        }

        var count = await products.CountAsync();
        TotalPages = (int)Math.Ceiling(count / (double)pageSize);

        if (Page > TotalPages)
        {
            Page = TotalPages;
        }
        if (Page <= 0)
        {
            Page = 1;
        }

        HasPrev = Page > 1;
        HasNext = Page < TotalPages;

        productsList = await products.Skip((Page - 1) * pageSize).Take(pageSize).ToArrayAsync();

        Loading = false;
    }

    private async Task Clear()
    {
        Page = 1;
        Sort = null;
        FilterGroup = null;
        SearchString = null;
        Products1price = null;

        await ReloadAsync();
    }

    private async Task GoFirstPage()
    {
        Page = 1;

        await ReloadAsync();
    }


    private async Task GoPreviousPage()
    {
        Page--;

        await ReloadAsync();
    }

    private async Task GoNextPage()
    {
        Page++;

        await ReloadAsync();
    }

    private async Task GoLastPage()
    {
        Page = TotalPages;

        await ReloadAsync();
    }
}
